<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mrdutq.github.io","root":"/blog/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="立心 立命 继绝学 开太平">
<meta property="og:type" content="website">
<meta property="og:title" content="Jason&#39;s blog">
<meta property="og:url" content="https://mrdutq.github.io/blog/page/7/index.html">
<meta property="og:site_name" content="Jason&#39;s blog">
<meta property="og:description" content="立心 立命 继绝学 开太平">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mrdutq.github.io/blog/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Jason's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/mrdutq" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrdutq.github.io/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="立心 立命 继绝学 开太平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/" class="post-title-link" itemprop="url">操作系统-虚拟存储器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-17 18:56:41" itemprop="dateCreated datePublished" datetime="2022-01-17T18:56:41+08:00">2022-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 20:50:00" itemprop="dateModified" datetime="2022-01-18T20:50:00+08:00">2022-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
<!-- 自定义，用于添加摘要图片，文章中不显示。文章开头添加 summary_img: 链接 即可 -->
      
<!-- 自定义结束 -->
          <h1 id="第五章：虚拟存储器"><a href="#第五章：虚拟存储器" class="headerlink" title="第五章：虚拟存储器"></a>第五章：虚拟存储器</h1><h2 id="常规存储管理方式的特征"><a href="#常规存储管理方式的特征" class="headerlink" title="常规存储管理方式的特征"></a>常规存储管理方式的特征</h2><h3 id="一次性"><a href="#一次性" class="headerlink" title="一次性"></a>一次性</h3><h3 id="驻留性"><a href="#驻留性" class="headerlink" title="驻留性"></a>驻留性</h3><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><h3 id="程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域"><a href="#程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域" class="headerlink" title="程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域"></a>程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域</h3><h3 id="时间局限性"><a href="#时间局限性" class="headerlink" title="时间局限性"></a>时间局限性</h3><ul>
<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作</li>
</ul>
<h3 id="空间局限性"><a href="#空间局限性" class="headerlink" title="空间局限性"></a>空间局限性</h3><ul>
<li>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统"><a href="#指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统" class="headerlink" title="指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统"></a>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</h3><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="大程序：可在较小的可用内存中执行较大的用户程序；"><a href="#大程序：可在较小的可用内存中执行较大的用户程序；" class="headerlink" title="大程序：可在较小的可用内存中执行较大的用户程序；"></a>大程序：可在较小的可用内存中执行较大的用户程序；</h3><h3 id="大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存-real-memory"><a href="#大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存-real-memory" class="headerlink" title="大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)"></a>大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)</h3><h3 id="并发：可在内存中容纳更多程序并发执行；"><a href="#并发：可在内存中容纳更多程序并发执行；" class="headerlink" title="并发：可在内存中容纳更多程序并发执行；"></a>并发：可在内存中容纳更多程序并发执行；</h3><h3 id="易于开发：不必影响编程时的程序结构"><a href="#易于开发：不必影响编程时的程序结构" class="headerlink" title="易于开发：不必影响编程时的程序结构"></a>易于开发：不必影响编程时的程序结构</h3><h3 id="以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术"><a href="#以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术" class="headerlink" title="以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术"></a>以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术</h3><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><h3 id="离散性"><a href="#离散性" class="headerlink" title="离散性"></a>离散性</h3><ul>
<li>指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础</li>
</ul>
<h3 id="多次性"><a href="#多次性" class="headerlink" title="多次性"></a>多次性</h3><ul>
<li>指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征</li>
</ul>
<h3 id="对换性"><a href="#对换性" class="headerlink" title="对换性"></a>对换性</h3><ul>
<li>指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。</li>
</ul>
<h3 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h3><ul>
<li>指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li>
</ul>
<h2 id="虚拟存储器的实现方式"><a href="#虚拟存储器的实现方式" class="headerlink" title="虚拟存储器的实现方式"></a>虚拟存储器的实现方式</h2><h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><ul>
<li>硬件<ul>
<li>请求页表机制<ul>
<li>格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址</li>
</ul>
</li>
<li>缺页中断机构</li>
<li>地址变换机构（过程图很关键）</li>
</ul>
</li>
<li>请求分页中的内存分配<ul>
<li>最小物理块数<ul>
<li>即能保证进程正常运行所需的最小物理块数</li>
</ul>
</li>
<li>内存分配策略<ul>
<li>固定分配局部置换（国王的大儿子）</li>
<li>可变分配全局置换（国王的二儿子）</li>
<li>可变分配局部置换（国王的小儿子）</li>
</ul>
</li>
</ul>
</li>
<li>物理块分配算法<ul>
<li>平均分配算法</li>
<li>按比例分配算法</li>
<li>考虑优先权的分配算法</li>
</ul>
</li>
<li>页面调入策略<ul>
<li>系统应在何时调入所需页面<ul>
<li>预调页策略（不能实现）</li>
<li>请求调页策略（需要才给）</li>
</ul>
</li>
<li>系统应该从何处调入这些页面<ul>
<li>对换区</li>
<li>文件区</li>
</ul>
</li>
<li>页面调入过程</li>
<li>缺页率（出计算题）</li>
</ul>
</li>
</ul>
<h3 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h3><ul>
<li>硬件<ul>
<li>请求分段的段表机构</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
</ul>
</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="抖动的概念"><a href="#抖动的概念" class="headerlink" title="抖动的概念"></a>抖动的概念</h3><ul>
<li>即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出</li>
</ul>
<h3 id="最佳置换算法-需要预知后面进程，所以不能实现"><a href="#最佳置换算法-需要预知后面进程，所以不能实现" class="headerlink" title="最佳置换算法(需要预知后面进程，所以不能实现)"></a>最佳置换算法(需要预知后面进程，所以不能实现)</h3><h3 id="先进先出页面置换算法（FIFO）"><a href="#先进先出页面置换算法（FIFO）" class="headerlink" title="先进先出页面置换算法（FIFO）"></a>先进先出页面置换算法（FIFO）</h3><ul>
<li>选择在内存中驻留时间最久的页面予以淘汰</li>
</ul>
<h3 id="最近最久未使用置换算法（LRU）Recently"><a href="#最近最久未使用置换算法（LRU）Recently" class="headerlink" title="最近最久未使用置换算法（LRU）Recently"></a>最近最久未使用置换算法（LRU）Recently</h3><ul>
<li>寄存器支持</li>
<li>特殊的栈结构</li>
</ul>
<h3 id="最少使用置换算法（LFU）Frequently"><a href="#最少使用置换算法（LFU）Frequently" class="headerlink" title="最少使用置换算法（LFU）Frequently"></a>最少使用置换算法（LFU）Frequently</h3><h3 id="clock置换算法（对访问位A的判断）"><a href="#clock置换算法（对访问位A的判断）" class="headerlink" title="clock置换算法（对访问位A的判断）"></a>clock置换算法（对访问位A的判断）</h3><ul>
<li>改进型——增加对修改位M思维判断</li>
</ul>
<h3 id="页面缓冲算法（PBA-page-buffering-algorithm）"><a href="#页面缓冲算法（PBA-page-buffering-algorithm）" class="headerlink" title="页面缓冲算法（PBA,page buffering algorithm）"></a>页面缓冲算法（PBA,page buffering algorithm）</h3><ul>
<li>空闲页面链表</li>
<li>修改页面链表</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mrdutq/cdn/images/os/ch5.png" alt="OS—CH5"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrdutq.github.io/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="立心 立命 继绝学 开太平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统-文件管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-17 18:56:41" itemprop="dateCreated datePublished" datetime="2022-01-17T18:56:41+08:00">2022-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 20:49:55" itemprop="dateModified" datetime="2022-01-18T20:49:55+08:00">2022-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
<!-- 自定义，用于添加摘要图片，文章中不显示。文章开头添加 summary_img: 链接 即可 -->
      
<!-- 自定义结束 -->
          <h1 id="第七章：文件管理"><a href="#第七章：文件管理" class="headerlink" title="第七章：文件管理"></a>第七章：文件管理</h1><h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><h3 id="基本数据项"><a href="#基本数据项" class="headerlink" title="基本数据项"></a>基本数据项</h3><h3 id="组合数据项"><a href="#组合数据项" class="headerlink" title="组合数据项"></a>组合数据项</h3><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><h3 id="记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性"><a href="#记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性" class="headerlink" title="记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性"></a>记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性</h3><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><h3 id="文件的物理位置"><a href="#文件的物理位置" class="headerlink" title="文件的物理位置"></a>文件的物理位置</h3><h3 id="文件的建立时间"><a href="#文件的建立时间" class="headerlink" title="文件的建立时间"></a>文件的建立时间</h3><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><h3 id="设置文件读写的位置"><a href="#设置文件读写的位置" class="headerlink" title="设置文件读写的位置"></a>设置文件读写的位置</h3><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><h3 id="记录寻址"><a href="#记录寻址" class="headerlink" title="记录寻址"></a>记录寻址</h3><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><h3 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h3><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块（FCB）"><a href="#文件控制块（FCB）" class="headerlink" title="文件控制块（FCB）"></a>文件控制块（FCB）</h3><ul>
<li>文件名+inode(属性)</li>
</ul>
<h3 id="简单的文件目录"><a href="#简单的文件目录" class="headerlink" title="简单的文件目录"></a>简单的文件目录</h3><ul>
<li>单级文件目录<ul>
<li>查找慢</li>
<li>不允许重名</li>
<li>不便于实现文件共享</li>
</ul>
</li>
<li>两级文件目录<ul>
<li>提高检索速度，从M*N到M+N</li>
</ul>
</li>
</ul>
<h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><ul>
<li>路径名<ul>
<li>“..”是父目录</li>
<li>“/”是根目录</li>
<li>区别绝对路径和相对路径（../…/…/1/2/3/）</li>
</ul>
</li>
</ul>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="有向无循环图（DAG）"><a href="#有向无循环图（DAG）" class="headerlink" title="有向无循环图（DAG）"></a>有向无循环图（DAG）</h3><h3 id="利用符号链接实现文件共享"><a href="#利用符号链接实现文件共享" class="headerlink" title="利用符号链接实现文件共享"></a>利用符号链接实现文件共享</h3><ul>
<li>实际上就是“快捷方式”</li>
</ul>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="https://cdn.jsdelivr.net/gh/mrdutq/cdn/images/os/ch7.png" alt="OS—CH7"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrdutq.github.io/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%BC%95%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="立心 立命 继绝学 开太平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%BC%95%E8%AE%BA/" class="post-title-link" itemprop="url">操作系统-引论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-17 18:56:41" itemprop="dateCreated datePublished" datetime="2022-01-17T18:56:41+08:00">2022-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 20:49:50" itemprop="dateModified" datetime="2022-01-18T20:49:50+08:00">2022-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
<!-- 自定义，用于添加摘要图片，文章中不显示。文章开头添加 summary_img: 链接 即可 -->
      
<!-- 自定义结束 -->
          <h1 id="一-操作系统引论"><a href="#一-操作系统引论" class="headerlink" title="一.操作系统引论"></a>一.操作系统引论</h1><h2 id="1-操作系统的目标和功能"><a href="#1-操作系统的目标和功能" class="headerlink" title="1.操作系统的目标和功能"></a>1.操作系统的目标和功能</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>方便性</li>
<li>有效性<ul>
<li>提高系统资源利用率</li>
<li>提高系统吞吐量</li>
</ul>
</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>OS作为用户与计算机硬件系统之间的接口<ul>
<li>命令方式</li>
<li>系统调用方式</li>
<li>图标–窗口方式</li>
</ul>
</li>
<li>OS实现了对计算机资源的抽象</li>
</ul>
<h2 id="2-操作系统的发展过程"><a href="#2-操作系统的发展过程" class="headerlink" title="2.操作系统的发展过程"></a>2.操作系统的发展过程</h2><h3 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h3><ul>
<li><p>人工操作方式</p>
</li>
<li><blockquote>
<p>用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率</p>
</blockquote>
</li>
<li><p>脱机输入/输出(Off–Line I/O)方式</p>
</li>
<li><blockquote>
<p>减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想</p>
</blockquote>
</li>
</ul>
<h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><blockquote>
<p>1.资源利用率高<br>2.系统吞吐量大<br>3.平均周转时间长<br>4.无交互能力</p>
</blockquote>
<ul>
<li>(宏观并行，微观串行)</li>
</ul>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><blockquote>
<p>特征:<br>1.多路性<br>2.独立性<br>3.及时性<br>4.交互性</p>
</blockquote>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>  指系统能及时（或即时）响应外部事件的请求，并控制所有实时任务协调一致地运行</p>
<blockquote>
<p>特征：<br>实时性和可靠性；多路性、独立性、交互性</p>
</blockquote>
<h3 id="集群系统–超算-云计算"><a href="#集群系统–超算-云计算" class="headerlink" title="集群系统–超算~云计算"></a>集群系统–超算~云计算</h3><h3 id="微机操作系统的发展"><a href="#微机操作系统的发展" class="headerlink" title="微机操作系统的发展"></a>微机操作系统的发展</h3><h2 id="3-操作系统的基本特征"><a href="#3-操作系统的基本特征" class="headerlink" title="3.操作系统的基本特征"></a>3.操作系统的基本特征</h2><h3 id="1-并发concurrence（最重要）"><a href="#1-并发concurrence（最重要）" class="headerlink" title="1.并发concurrence（最重要）"></a>1.并发concurrence（最重要）</h3><ul>
<li><p>并发（Concurrence）：在一段时间内同时存在多道运行地程序（进程）。</p>
</li>
<li><blockquote>
<p>宏观上：多道程序同时在执行。</p>
</blockquote>
</li>
<li><blockquote>
<p>微观上：在单处理及系统中，任何时刻只有一道程序在执行，即微观上多道程序在CPU上交替执行。</p>
</blockquote>
</li>
<li><p>并行（Parallel）：指多道程序在同一时刻执行，通常需要多个硬件支持。</p>
</li>
<li><p>区别并行和并发</p>
</li>
<li><blockquote>
<p>并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行</p>
</blockquote>
</li>
<li><blockquote>
<p>并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行</p>
</blockquote>
<ul>
<li>并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行</li>
</ul>
</li>
<li><p>引入进程</p>
</li>
<li><blockquote>
<p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体。通常地程序时静态实体。</p>
</blockquote>
</li>
<li><p>引入线程</p>
</li>
<li><blockquote>
<p>通常在一个进程中可以包含若干个线程，把线程作为独立运行和独立调度地基本单位。线程基本上不拥有系统资源，调度开销小，能提高系统内多个程序间并发执行的程度。</p>
</blockquote>
</li>
</ul>
<h3 id="2-共享sharing"><a href="#2-共享sharing" class="headerlink" title="2.共享sharing"></a>2.共享sharing</h3><p>  指系统中的资源不再为某道程序所独占，而是供多道程序共同使用。</p>
<ul>
<li>1.互斥共享方式</li>
<li>2.同时访问方式</li>
<li>并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件</li>
</ul>
<h3 id="3-虚拟virtual"><a href="#3-虚拟virtual" class="headerlink" title="3.虚拟virtual"></a>3.虚拟virtual</h3><p>  虚拟是操作系统管理系统资源的重要手段，可提高资源利用率。</p>
<ul>
<li>时分复用，即分时使用方式。如：虚拟处理机、虚拟设备。</li>
<li>空分复用，用于提高存储空间的利用率。如：虚拟磁盘、虚拟存储器。</li>
</ul>
<h3 id="4-异步asynchronism"><a href="#4-异步asynchronism" class="headerlink" title="4.异步asynchronism"></a>4.异步asynchronism</h3><p>  异步性也称不确定性，指进程在执行中，其执行时间、顺序、向前推进的速度和完成的时间等都是不可预知的。</p>
<p>  “不确定性”不是说操作系统的功能不确定，也不是说同一程序在相同的数据集上的多次运行结果不确定，而是指同一道程序的多次运行所需的时间不确定，同一批程序的多次运行的运行序列和总运行时间不确定。</p>
<h2 id="4-操作系统的主要功能"><a href="#4-操作系统的主要功能" class="headerlink" title="4.操作系统的主要功能"></a>4.操作系统的主要功能</h2><h3 id="1-处理机管理功能"><a href="#1-处理机管理功能" class="headerlink" title="1.处理机管理功能"></a>1.处理机管理功能</h3><ul>
<li>进程控制</li>
<li>进程同步<ul>
<li>进程互斥方式</li>
<li>进程同步方式(协同)</li>
</ul>
</li>
<li>进程通信</li>
<li>调度<ul>
<li>作业调度</li>
<li>进程调度</li>
</ul>
</li>
</ul>
<h3 id="2-存储器管理功能"><a href="#2-存储器管理功能" class="headerlink" title="2.存储器管理功能"></a>2.存储器管理功能</h3><ul>
<li>内存分配<ul>
<li>静态分配</li>
<li>动态分配</li>
</ul>
</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
<h3 id="3-设备管理功能"><a href="#3-设备管理功能" class="headerlink" title="3.设备管理功能"></a>3.设备管理功能</h3><ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理<ul>
<li>设备处理程序又称设备驱动程序</li>
</ul>
</li>
</ul>
<h3 id="4-文件管理功能"><a href="#4-文件管理功能" class="headerlink" title="4.文件管理功能"></a>4.文件管理功能</h3><ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读写管理和保护</li>
</ul>
<h3 id="5-操作系统与用户之间的接口"><a href="#5-操作系统与用户之间的接口" class="headerlink" title="5.操作系统与用户之间的接口"></a>5.操作系统与用户之间的接口</h3><ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
<h3 id="6-现代操作系统的新功能"><a href="#6-现代操作系统的新功能" class="headerlink" title="6.现代操作系统的新功能"></a>6.现代操作系统的新功能</h3><ul>
<li>系统安全</li>
<li>网络的功能和服务</li>
<li>支持多媒体</li>
</ul>
<h2 id="5-OS结构设计"><a href="#5-OS结构设计" class="headerlink" title="5.OS结构设计"></a>5.OS结构设计</h2><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><ul>
<li>无结构操作系统</li>
<li>模块化OS</li>
<li>分层式结构OS</li>
</ul>
<h3 id="微内核os结构"><a href="#微内核os结构" class="headerlink" title="微内核os结构"></a>微内核os结构</h3><ul>
<li>客户/服务器模式（客户机、服务器、网络系统）</li>
<li>面对对象的程序设计（封装、继承、多态）</li>
<li>机制与策略分离<blockquote>
<p>机制 (Mechanism)，是指实现某一功能的具体执行机构。<br>策略 (Policy)，是在机制的基础上，借助于某些参数和算法来实现该功能的方法。<br>简单理解：软件是策略，硬件是机制。命令是策略，实施是机制。</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mrdutq/cdn/images/os/ch1.png" alt="OS_CH1"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrdutq.github.io/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="立心 立命 继绝学 开太平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统-存储器管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-17 18:56:41" itemprop="dateCreated datePublished" datetime="2022-01-17T18:56:41+08:00">2022-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 20:49:40" itemprop="dateModified" datetime="2022-01-18T20:49:40+08:00">2022-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
<!-- 自定义，用于添加摘要图片，文章中不显示。文章开头添加 summary_img: 链接 即可 -->
      
<!-- 自定义结束 -->
          <h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章:存储器管理"></a>第四章:存储器管理</h1><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="多层结构的存储系统"><a href="#多层结构的存储系统" class="headerlink" title="多层结构的存储系统"></a>多层结构的存储系统</h3><ul>
<li>存储器的多层结构<ul>
<li>CPU寄存器</li>
<li>主存</li>
<li>辅存</li>
</ul>
</li>
<li>可执行存储器<ul>
<li>寄存器和主存的总称</li>
<li>访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。</li>
</ul>
</li>
</ul>
<h3 id="主存储器与寄存器"><a href="#主存储器与寄存器" class="headerlink" title="主存储器与寄存器"></a>主存储器与寄存器</h3><h3 id="高速缓存和磁盘缓存"><a href="#高速缓存和磁盘缓存" class="headerlink" title="高速缓存和磁盘缓存"></a>高速缓存和磁盘缓存</h3><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>编译<ul>
<li>源程序 -&gt;目标模块（Object modules）——–Compiler<ul>
<li>由编译程序对用户源程序进行编译，形成若干个目标模块</li>
</ul>
</li>
</ul>
</li>
<li>链接<ul>
<li>一组目标模块 -&gt;装入模块 （Load Module）———-Linker<ul>
<li>由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块</li>
</ul>
</li>
</ul>
</li>
<li>装入<ul>
<li>装入模块 -&gt;内存  ——–Loader<ul>
<li>由装入程序将装入模块装入内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><ul>
<li>绝对装入方式<ul>
<li>在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。</li>
</ul>
</li>
<li>可重定位装入方式<ul>
<li>在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。</li>
<li>优点：不需硬件支持，可以装入有限多道程序。</li>
<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。</li>
</ul>
</li>
<li>动态运行时的装入方式<ul>
<li>动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行</li>
<li>优点：<ul>
<li>OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。</li>
<li>能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。</li>
</ul>
</li>
<li>缺点：需要硬件支持，OS实现较复杂。</li>
<li>它是虚拟存储的基础。</li>
</ul>
</li>
</ul>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ul>
<li>静态链接方式(lib)</li>
<li>装入时动态链接</li>
<li>运行时动态链接(dll)</li>
</ul>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><ul>
<li>单一连续分配(DOS)</li>
<li>固定分区分配(浪费很多空间)</li>
<li>动态分区分配</li>
</ul>
<h3 id="地址映射和存储保护措施"><a href="#地址映射和存储保护措施" class="headerlink" title="地址映射和存储保护措施"></a>地址映射和存储保护措施</h3><ul>
<li>基址寄存器：程序的最小物理地址</li>
<li>界限寄存器：程序的逻辑地址范围</li>
<li>物理地址 = 逻辑地址 + 基址</li>
</ul>
<h3 id="内碎片：占用分区之内未被利用的空间"><a href="#内碎片：占用分区之内未被利用的空间" class="headerlink" title="内碎片：占用分区之内未被利用的空间"></a>内碎片：占用分区之内未被利用的空间</h3><h3 id="外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）"><a href="#外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）" class="headerlink" title="外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）"></a>外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）</h3><h3 id="把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。"><a href="#把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。" class="headerlink" title="把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。"></a>把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。</h3><ul>
<li>分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。</li>
<li>分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</li>
<li>优点：无外碎片、易实现、开销小。</li>
<li>缺点：<ul>
<li>存在内碎片，造成浪费</li>
<li>分区总数固定，限制了并发执行的程序数目。</li>
<li>通用Os很少采用，部分控制系统中采用</li>
</ul>
</li>
</ul>
<h3 id="动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。"><a href="#动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。" class="headerlink" title="动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。"></a>动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。</h3><ul>
<li>基于顺序搜索的动态分区分配算法<ul>
<li>首次适应算法（first fit,FF）<ul>
<li>顺序找，找到一个满足的就分配，但是可能存在浪费</li>
<li>这种方法目的在于减少查找时间。</li>
<li>空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序</li>
</ul>
</li>
<li>循环首次适应算法（next fit，NF）<ul>
<li>相对上面那种，不是顺序，类似哈希算法中左右交叉排序</li>
<li>空闲分区分布得更均匀，查找开销小</li>
<li>从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。</li>
</ul>
</li>
<li>最佳适应算法（best fit，BF）<ul>
<li>找到最合适的，但是大区域的访问次数减少</li>
<li>这种方法能使外碎片尽量小。</li>
<li>空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。</li>
</ul>
</li>
<li>最坏适应算法（worst fit，WF）<ul>
<li>相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片</li>
<li>空闲分区按大小由大到小排序</li>
</ul>
</li>
</ul>
</li>
<li>基于索引搜索的动态分区分配算法<ul>
<li>快速适应算法（quick fit）</li>
<li>伙伴系统（buddy system）</li>
<li>哈希算法</li>
</ul>
</li>
<li>动态可重定位分区分配<ul>
<li>紧凑</li>
<li>动态重定位<ul>
<li>动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持</li>
<li>内存地址=相对地址+起始地址</li>
</ul>
</li>
<li>动态重定位分区分配算法<ul>
<li>1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。</li>
<li>2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：</li>
</ul>
</li>
</ul>
</li>
<li>优点：没有内碎片。</li>
<li>缺点：外碎片。</li>
</ul>
<h2 id="对换（了解）"><a href="#对换（了解）" class="headerlink" title="对换（了解）"></a>对换（了解）</h2><h3 id="系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。"><a href="#系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。" class="headerlink" title="系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。"></a>系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。</h3><h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h3 id="分页存储管理的基本方式"><a href="#分页存储管理的基本方式" class="headerlink" title="分页存储管理的基本方式"></a>分页存储管理的基本方式</h3><ul>
<li>页面<ul>
<li>将一个进程的逻辑地址空间分成若干个大小相等的片</li>
</ul>
</li>
<li>页框（frame）<ul>
<li>内存空间分成与页面相同大小的存储块</li>
</ul>
</li>
<li>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”</li>
<li>地址结构<ul>
<li>页号P+位移量W(0-31)</li>
</ul>
</li>
<li>页表<ul>
<li>在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表</li>
<li>页表的作用是实现从页面号到物理块号的地址映射</li>
</ul>
</li>
</ul>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><ul>
<li>基本的地址变换机构<ul>
<li>要访问两次内存</li>
<li>页表大都驻留在内存中</li>
<li>为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。</li>
<li>在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。</li>
</ul>
</li>
<li>具有快表的地址变换机构<ul>
<li>提高了效率，此处会有计算题</li>
<li>如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1/2。</li>
<li>为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。</li>
<li>地址变换过程为：<ul>
<li>1、CPU给出有效地址</li>
<li>2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。</li>
<li>3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；</li>
<li>4、若快表中未找到对应的页表项，则需再访问内存中的页表</li>
<li>5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><ul>
<li>主要是有的时候页表太多了，要化简</li>
<li>格式：外层页号P1+外层页内地址P2+页内地址d</li>
<li>基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。</li>
</ul>
<h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><ul>
<li>反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>没有外碎片，每个内碎片不超过页大小。</li>
<li>一个程序不必连续存放。</li>
<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>
</ul>
<h3 id="缺点：程序全部装入内存。"><a href="#缺点：程序全部装入内存。" class="headerlink" title="缺点：程序全部装入内存。"></a>缺点：程序全部装入内存。</h3><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul>
<li>方便编程</li>
<li>信息共享</li>
<li>动态增长</li>
<li>动态链接</li>
</ul>
<h3 id="在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。"><a href="#在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。" class="headerlink" title="在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。"></a>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。</h3><h3 id="内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定"><a href="#内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定" class="headerlink" title="内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定"></a>内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定</h3><h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><ul>
<li>分段<ul>
<li>格式：段号+段内地址</li>
</ul>
</li>
<li>段表<ul>
<li>段表实现了从逻辑段到物理内存区的映射。</li>
</ul>
</li>
<li>地址变换机构</li>
</ul>
<h3 id="和分页的区别"><a href="#和分页的区别" class="headerlink" title="和分页的区别"></a>和分页的区别</h3><ul>
<li>页是信息的物理单位</li>
<li>页的大小固定且由系统固定</li>
<li>分页的用户程序地址空间是一维的</li>
<li>通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。</li>
<li>分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>
</ul>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><ul>
<li>这是分段最重要的优点</li>
</ul>
<h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ul>
<li>基本原理<ul>
<li>格式：段号（S）+段内页号（P）+页内地址（W）</li>
</ul>
</li>
<li>地址变换过程<ul>
<li>需要三次访问过程</li>
</ul>
</li>
<li>在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mrdutq/cdn/images/os/ch4.png" alt="OS—CH4"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrdutq.github.io/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="立心 立命 继绝学 开太平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/01/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">操作系统-处理机调度与死锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-17 18:56:41" itemprop="dateCreated datePublished" datetime="2022-01-17T18:56:41+08:00">2022-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-18 20:49:33" itemprop="dateModified" datetime="2022-01-18T20:49:33+08:00">2022-01-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
<!-- 自定义，用于添加摘要图片，文章中不显示。文章开头添加 summary_img: 链接 即可 -->
      
<!-- 自定义结束 -->
          <h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章:处理机调度与死锁"></a>第三章:处理机调度与死锁</h1><h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><h3 id="处理机调度算法的共同目标"><a href="#处理机调度算法的共同目标" class="headerlink" title="处理机调度算法的共同目标"></a>处理机调度算法的共同目标</h3><ul>
<li>资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)</li>
<li>公平性</li>
<li>平衡性</li>
<li>策略强制执行</li>
</ul>
<h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3><ul>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高</li>
</ul>
<h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3><ul>
<li>响应时间快</li>
<li>均衡性</li>
</ul>
<h3 id="实时系统目标"><a href="#实时系统目标" class="headerlink" title="实时系统目标"></a>实时系统目标</h3><ul>
<li>截止时间的保证</li>
<li>可预测性</li>
</ul>
<h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul>
<li>高级调度（作业调度）<ul>
<li>分时系统无需作业调度，因为需要交互</li>
<li>批处理系统需要作业调度</li>
</ul>
</li>
<li>中级调度（和挂起有关）</li>
<li>低级调度（进程调度）<ul>
<li>进程调度是最基本的调度，任何操作系统都有进程调度。</li>
<li>低级调度的三个基本机制<ul>
<li>排队器</li>
<li>分派器</li>
<li>上下文切换</li>
</ul>
</li>
<li>进程调度方式<ul>
<li>非抢占方式</li>
<li>抢占方式<ul>
<li>优先权原则</li>
<li>短进程优先原则</li>
<li>时间片原则</li>
</ul>
</li>
</ul>
</li>
<li>进程调度的任务<ul>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理器分配给进程</li>
</ul>
</li>
<li>进程调度的算法<ul>
<li>优先级调度算法<ul>
<li>优先级调度算法的类型<ul>
<li>非抢占式优先级调度算法<ul>
<li>等当前进程执行完以后，再执行另一个优先权最高的进程</li>
<li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 </li>
</ul>
</li>
<li>抢占式优先级调度算法<ul>
<li>不等当前进程结束，直接抢处理机</li>
<li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
</ul>
</li>
<li>优先级的类型<ul>
<li>静态优先级<ul>
<li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li>
<li>可以参考BIOS系统中设置boot的优先级</li>
</ul>
</li>
<li>动态优先级<ul>
<li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>轮转调度算法<ul>
<li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li>
<li>进程切换时机<ul>
<li>时间片未用完，进程完成</li>
<li>时间片到，进程未完成</li>
</ul>
</li>
<li>时间片大小的确定<ul>
<li>太小利于短作业，增加系统切换开销</li>
<li>太长就退化为FCFS算法</li>
<li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li>
</ul>
</li>
<li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li>
</ul>
</li>
<li>多队列调度算法</li>
<li>多级反馈队列调度算法<ul>
<li>调度机制<ul>
<li>设置多个就绪队列</li>
<li>每个队列都采用FCFS算法</li>
<li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li>
</ul>
</li>
<li>调度算法的性能<ul>
<li>对于终端型用户，由于作业小，感觉满意</li>
<li>对于短批处理作业用户，周转时间也较小</li>
<li>长批处理作业用户，也能够得到执行</li>
</ul>
</li>
</ul>
</li>
<li>基于公平原则的调度算法<ul>
<li>保证调度算法</li>
<li>公平分享调度算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul>
<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</li>
</ul>
<h3 id="作业控制块JCB"><a href="#作业控制块JCB" class="headerlink" title="作业控制块JCB"></a>作业控制块JCB</h3><ul>
<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</li>
</ul>
<h3 id="作业步"><a href="#作业步" class="headerlink" title="作业步"></a>作业步</h3><ul>
<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</li>
</ul>
<h3 id="作业运行的三个阶段"><a href="#作业运行的三个阶段" class="headerlink" title="作业运行的三个阶段"></a>作业运行的三个阶段</h3><ul>
<li>收容阶段</li>
<li>运行阶段</li>
<li>完成阶段</li>
</ul>
<h3 id="作业运行的三个状态"><a href="#作业运行的三个状态" class="headerlink" title="作业运行的三个状态"></a>作业运行的三个状态</h3><ul>
<li>后备状态</li>
<li>运行状态</li>
<li>完成状态</li>
</ul>
<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><ul>
<li>接纳多少个作业</li>
<li>接纳哪些作业</li>
</ul>
<h3 id="先来先服务-first–come-first–served，FCFS-调度算法"><a href="#先来先服务-first–come-first–served，FCFS-调度算法" class="headerlink" title="先来先服务(first–come first–served，FCFS)调度算法"></a>先来先服务(first–come first–served，FCFS)调度算法</h3><ul>
<li>比较有利于长作业，而不利于短作业。</li>
<li>有利于CPU繁忙的作业，而不利于I/O繁忙的作业。</li>
</ul>
<h3 id="短作业优先-short-job-first，SJF-的调度算法"><a href="#短作业优先-short-job-first，SJF-的调度算法" class="headerlink" title="短作业优先(short job first，SJF)的调度算法"></a>短作业优先(short job first，SJF)的调度算法</h3><ul>
<li>优点<ul>
<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>
<li>提高系统的吞吐量；</li>
</ul>
</li>
<li>缺点<ul>
<li>必须预知作业的运行时间</li>
<li>对长作业非常不利，长作业的周转时间会明显地增长</li>
<li>在采用SJF算法时，人–机无法实现交互</li>
<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</li>
</ul>
</li>
</ul>
<h3 id="优先级调度算法-priority–scheduling-algorithm，PSA"><a href="#优先级调度算法-priority–scheduling-algorithm，PSA" class="headerlink" title="优先级调度算法(priority–scheduling algorithm，PSA)"></a>优先级调度算法(priority–scheduling algorithm，PSA)</h3><h3 id="高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN"><a href="#高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN" class="headerlink" title="高响应比优先调度算法(Highest Response Ratio Next,HRRN)"></a>高响应比优先调度算法(Highest Response Ratio Next,HRRN)</h3><ul>
<li>原理<ul>
<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>
<li>优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间</li>
</ul>
</li>
<li>特点<ul>
<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>
<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>
<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机</li>
</ul>
</li>
</ul>
<h2 id="实时调度-HRT和SRT任务"><a href="#实时调度-HRT和SRT任务" class="headerlink" title="实时调度(HRT和SRT任务)"></a>实时调度(HRT和SRT任务)</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ul>
<li>提供必要信息<ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
</li>
<li>系统处理能力强<ul>
<li>∑(Ci/Pi)≤1</li>
<li>N个处理机:∑(Ci/Pi)≤N</li>
</ul>
</li>
<li>采用抢占式调度机制</li>
<li>具有快速切换机制<ul>
<li>对中断的快速响应能力</li>
<li>快速的任务分派能力</li>
</ul>
</li>
</ul>
<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3><ul>
<li>非抢占式调度算法<ul>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
</ul>
</li>
<li>抢占式调度算法<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法</li>
</ul>
</li>
</ul>
<h3 id="最早截止时间优先EDF-Earliest-Deadline-First-算法"><a href="#最早截止时间优先EDF-Earliest-Deadline-First-算法" class="headerlink" title="最早截止时间优先EDF(Earliest Deadline First)算法"></a>最早截止时间优先EDF(Earliest Deadline First)算法</h3><ul>
<li>根据任务的开始截至时间来确定任务的优先级<ul>
<li>截至时间越早，优先级越高</li>
</ul>
</li>
<li>非抢占式调度方式用于非周期实时任务</li>
<li>抢占式调度方式用于周期实时任务</li>
</ul>
<h3 id="最低松弛度优先LLF-Least-Laxity-First-算法"><a href="#最低松弛度优先LLF-Least-Laxity-First-算法" class="headerlink" title="最低松弛度优先LLF(Least Laxity First)算法"></a>最低松弛度优先LLF(Least Laxity First)算法</h3><ul>
<li>类似EDF</li>
<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>
<li>松弛度例子<ul>
<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</li>
</ul>
</li>
</ul>
<h3 id="优先级倒置-Priority-inversion-problem"><a href="#优先级倒置-Priority-inversion-problem" class="headerlink" title="优先级倒置(Priority inversion problem)"></a>优先级倒置(Priority inversion problem)</h3><ul>
<li>优先级倒置的形成<ul>
<li>高优先级进程被低优先级进程延迟或阻塞。</li>
</ul>
</li>
<li>优先级倒置的解决方法<ul>
<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>
<li>实用的:建立在动态优先级继承基础上的</li>
</ul>
</li>
</ul>
<h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><ul>
<li>可重用性资源<ul>
<li>计算机外设</li>
</ul>
</li>
<li>消耗性资源<ul>
<li>数据，消息</li>
</ul>
</li>
<li>可抢占性资源<ul>
<li> 不引起死锁</li>
<li>CPU，内存 </li>
</ul>
</li>
<li>不可抢占性资源<ul>
<li>光驱，打印机</li>
</ul>
</li>
</ul>
<h3 id="计算机系统中的死锁"><a href="#计算机系统中的死锁" class="headerlink" title="计算机系统中的死锁"></a>计算机系统中的死锁</h3><ul>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ul>
<h3 id="死锁的定义，必要条件和处理方法"><a href="#死锁的定义，必要条件和处理方法" class="headerlink" title="死锁的定义，必要条件和处理方法"></a>死锁的定义，必要条件和处理方法</h3><ul>
<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li>产生死锁的必要条件<ul>
<li>互斥条件</li>
<li>请求和保存条件</li>
<li>不可抢占条件</li>
<li>循环等待条件<ul>
<li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li>
</ul>
</li>
</ul>
</li>
<li>处理死锁的方法<ul>
<li>预防死锁<ul>
<li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li>
<li>预防死锁的策略<ul>
<li>破坏”请求和保存”条件<ul>
<li>第一种协议<ul>
<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>
<li>优点:简单，易行，安全</li>
<li>缺点<ul>
<li>资源被严重浪费，严重地恶化了资源的利用率</li>
<li>使进程经常会发生饥饿现象</li>
</ul>
</li>
</ul>
</li>
<li>第二种协议<ul>
<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>
</ul>
</li>
</ul>
</li>
<li>破坏”不可抢占”条件<ul>
<li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li>
</ul>
</li>
<li>破坏”循环等待”条件<ul>
<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>
<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>避免死锁<ul>
<li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li>
<li>避免死锁的策略<ul>
<li>系统安全状态<ul>
<li>安全状态<ul>
<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>
</ul>
</li>
<li>安全状态之例</li>
<li>由安全状态向不安全状态的转换</li>
</ul>
</li>
<li>利用银行家算法避免死锁<ul>
<li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li>
<li>银行家算法中的数据结构<ul>
<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。</li>
<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。</li>
<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。</li>
<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]</li>
</ul>
</li>
<li>银行家算法</li>
<li>安全性算法</li>
<li>银行家算法之例</li>
<li>解题<ul>
<li>矩阵</li>
<li>列表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>检测死锁<ul>
<li>死锁的检测与解除<ul>
<li>死锁的检测<ul>
<li>资源分配图<ul>
<li>简化步骤<ul>
<li>选择一个没有阻塞的进程p</li>
<li>将p移走，包括它的所有请求边和分配边</li>
<li>重复步骤1，2，直至不能继续下去</li>
</ul>
</li>
</ul>
</li>
<li>死锁定理<ul>
<li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li>
</ul>
</li>
<li>检测时机<ul>
<li> 当进程等待时检测死锁 （其缺点是系统的开销大）</li>
<li> 定时检测</li>
<li> 系统资源利用率下降时检测死锁</li>
</ul>
</li>
<li>死锁检测中的数据结构</li>
</ul>
</li>
<li>死锁的解除<ul>
<li>抢占资源</li>
<li>终止(或撤销)进程</li>
<li>终止进程的方法<ul>
<li>终止所有死锁进程</li>
<li>逐个终止进程<ul>
<li>代价最小<ul>
<li>进程的优先级的大小</li>
<li>进程已执行了多少时间，还需时间</li>
<li>进程在运行中已经使用资源的多少，还需多少资源</li>
<li>进程的性质是交互式还是批处理的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>付出代价最小的死锁解除算法<ul>
<li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>解除死锁</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/mrdutq/cdn/images/os/ch3.png" alt="OS—CH3"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/blog/page/8/">8</a><a class="page-number" href="/blog/page/9/">9</a><a class="extend next" rel="next" href="/blog/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description">立心 立命 继绝学 开太平</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mrdutq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mrdutq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:dutianqi9911@163.com" title="E-Mail → mailto:dutianqi9911@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      学习链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://equsky.cn/" title="https:&#x2F;&#x2F;equsky.cn" rel="noopener" target="_blank">Jason's Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://51world.win/" title="https:&#x2F;&#x2F;51world.win" rel="noopener" target="_blank">时间的朋友</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://linwhitehat.github.io/Blog/about" title="https:&#x2F;&#x2F;linwhitehat.github.io&#x2F;Blog&#x2F;about" rel="noopener" target="_blank">林深时见璐</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ebook2.lorefree.com/" title="https:&#x2F;&#x2F;ebook2.lorefree.com" rel="noopener" target="_blank">Ebook</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.ethanloo.top/" title="https:&#x2F;&#x2F;www.ethanloo.top" rel="noopener" target="_blank">Ethan</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baidu.com/" title="https:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">baidu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">google</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.youtube.com/" title="https:&#x2F;&#x2F;www.youtube.com" rel="noopener" target="_blank">youtube</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>

<script src="/blog/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
