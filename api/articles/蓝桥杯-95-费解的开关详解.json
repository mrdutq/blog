{"title":"蓝桥杯-95.费解的开关2021/03/10","uid":"1b5a1b151f5f6c9cafa34c99fdd17e6f","slug":"蓝桥杯-95-费解的开关详解","date":"2022-01-17T10:56:41.894Z","updated":"2021-03-10T15:32:21.346Z","comments":true,"path":"api/articles/蓝桥杯-95-费解的开关详解.json","keywords":null,"cover":null,"content":"<h1 id=\"题目：95-费解的开关\"><a href=\"#题目：95-费解的开关\" class=\"headerlink\" title=\"题目：95.费解的开关\"></a>题目：95.费解的开关</h1><h2 id=\"题目介绍\"><a href=\"#题目介绍\" class=\"headerlink\" title=\"题目介绍\"></a>题目介绍</h2><p>你玩过“拉灯”游戏吗？</p>\n<p>25 盏灯排成一个 5×5 的方形。</p>\n<p>每一个灯都有一个开关，游戏者可以改变它的状态。</p>\n<p>每一步，游戏者可以改变某一个灯的状态。</p>\n<p>游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。</p>\n<p>我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。</p>\n<p>下面这种状态：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">10111\n01101\n10111\n10000\n11011<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在改变了最左上角的灯的状态后将变成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">01111\n11101\n10111\n10000\n11011<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再改变它正中间的灯后状态将变成：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">01111\n11001\n11001\n10100\n11011<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。</p>\n<p><strong>输入格式</strong><br>第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。</p>\n<p>以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。</p>\n<p>每组数据描述了一个游戏的初始状态。</p>\n<p>各组数据间用一个空行分隔。</p>\n<p><strong>输出格式</strong><br>一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。</p>\n<p>对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。</p>\n<p><strong>数据范围</strong></p>\n<p>0&lt;n≤500</p>\n<p><strong>输入样例</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">3\n00111\n01011\n10001\n11010\n11100\n\n11101\n11101\n11110\n11111\n11111\n\n01111\n11111\n11111\n11111\n11111<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>输出样例</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">3\n2\n-1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>一旦第一行开关确定，，那么第一行为0的开关只能由第二行的开关调整为1。<br>第一行由第二行确定，第二行由第三行确定…</p>\n<p>第i行由第i-1行确定。</p>\n<h2 id=\"题解（代码）\"><a href=\"#题解（代码）\" class=\"headerlink\" title=\"题解（代码）\"></a>题解（代码）</h2><pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">import java.util.*;\n\npublic class Main&#123;\n    \n    static final int INF &#x3D; 1000000;\n    static char[][] g &#x3D; new char[10][10];\n    static int[] dx &#x3D; &#123; 0, -1, 0, 1, 0 &#125;;\n    static int[] dy &#x3D; &#123; 0, 0, 1, 0, -1 &#125;;\n    \n    &#x2F;&#x2F;枚举，以(x,y)为中心的五个数\n    private static void turn(int x, int y)&#123;\n        for(int i &#x3D; 0; i&lt;5 ; i++)&#123;\n            int a &#x3D; x + dx[i], b &#x3D; y+dy[i];\n            if(a &gt;&#x3D; 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 5)\n            &#123;\n                g[a][b]^&#x3D;1;&#x2F;&#x2F;异或\n            &#125;\n        &#125;\n    &#125;\n    \n    private static int work()&#123;\n        int ans &#x3D; INF;\n\n        &#x2F;&#x2F;1&lt;&lt;5;二进制1左移五位；00000001&lt;&lt;5&#x3D;&#x3D;&#x3D;》00100000 &#x3D;&#x3D;&#x3D;》十进制32 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 每行5位 每位有0&#x2F;1两种状态 对应10进制的0~31\n        &#x2F;&#x2F; 这里我们枚举了第一行的32种按法，不用管是亮是灭，把第一行所有情况都按一遍\n        &#x2F;&#x2F; 按每种情况的第一行，去遍历接下来的行\n        &#x2F;&#x2F; 枚举32种第一行的按法只是可能会减少步数，如果直接从第二行开始答案一定是固定的了，找不到最优解或者可能没有解\n        &#x2F;&#x2F; 因为第一行是可以按的，我们的目的是先确定第一行，所以先枚举第一行的32种情况，\n        for(int k &#x3D; 0; k &lt; 1 &lt;&lt; 5; k++) &#x2F;&#x2F;枚举第一行的所有情况，_ _ _ _ _ 第一行五个位置，用五个二进制表示，如果有位置有1，说明该位置需要按开关，遍历第一行所有情况即可得到最优解\n        &#123;\n            int res &#x3D; 0;\n            &#x2F;&#x2F; 保护源数组\n            char backup[][] &#x3D; new char[10][10];\n            for(int i &#x3D; 0; i &lt; g.length; i++)&#123;\n                for(int j &#x3D; 0; j &lt; g[i].length; j++)&#123;\n                    backup[i][j] &#x3D; g[i][j];\n                &#125;\n            &#125;\n            &#x2F;&#x2F; memcpy(backup,g,sizeof g);\n            \n            \n            for(int j &#x3D; 0; j &lt; 5; j ++)\n            &#123;\n                &#x2F;&#x2F;第一行枚举的k的第j位如果是1，是指第一行的这一位应该被切换状态(开灯或关灯)，而和其初始状态无关\n                if( (k&gt;&gt;j&amp;1) &#x3D;&#x3D; 1 )&#x2F;&#x2F; 如果k的第j位为1（从低位开始的位数）表示需要按开关\n                &#123;\n                    res ++;\n                    turn(0,j);&#x2F;&#x2F;调整第0行的第j个开关\n                &#125;\n            &#125;\n\n            &#x2F;&#x2F;递推\n            for(int i &#x3D; 0; i&lt;4; i++)\n            &#x2F;&#x2F;i&lt;4 是因为枚举第i行时要把第i+1行的灯都按掉，所以只能枚举到倒数第二行，不能枚举最后一行\n                for(int j &#x3D; 0; j &lt; 5; j++)\n                    if(g[i][j] &#x3D;&#x3D; &#39;0&#39;)\n                    &#123;\n                        res++;\n                        turn(i+1,j);\n                    &#125;\n            \n            boolean is_successful &#x3D; true;\n            for(int j &#x3D; 0; j &lt; 5; j ++)\n                if(g[4][j] &#x3D;&#x3D; &#39;0&#39;)\n                &#123;\n                    is_successful &#x3D; false;\n                    break;\n                &#125;\n            \n            if(is_successful) ans &#x3D; Math.min(ans , res);\n            &#x2F;&#x2F;g数组恢复原状\n            &#x2F;&#x2F;memcpy(g,backup,sizeof g);\n            for(int i &#x3D; 0; i &lt; g.length; i++)&#123;\n                for(int j &#x3D; 0; j &lt; g[i].length; j++)&#123;\n                     g[i][j] &#x3D; backup[i][j];\n                &#125;\n            &#125;\n        &#125;\n        if(ans &gt; 6) ans &#x3D;  -1;\n        return ans;\n    &#125;\n    \n    public static void main(String args[])&#123;\n        Scanner in &#x3D; new Scanner(System.in);\n        int T; \n        T &#x3D; in.nextInt();\n        while(T-- !&#x3D; 0)\n        &#123;\n            for(int i &#x3D; 0; i &lt; 5; i++) \n                    g[i] &#x3D; in.next().toCharArray();\n            System.out.println(work());\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nconst int INF &#x3D; 1000000;\n\nchar g[10][10];\nint dx[5] &#x3D; &#123;0, -1, 0, 1, 0&#125;, dy[5] &#x3D; &#123;0, 0, 1, 0, -1&#125;;\n&#x2F;&#x2F;向量：dx[5] &#x3D;&#123; 中间，上，右，下，左&#125;； dy[5] &#x3D; &#123;中间，上，右，下，左 &#125;\nvoid turn(int x, int y)\n&#123;\n    &#x2F;&#x2F;枚举，以(x,y)为中心的五个数\n    for(int i &#x3D; 0; i&lt;5 ; i++)\n    &#123;\n        &#x2F;&#x2F;求以(x,y)为中心的五个数的坐标\n        int a &#x3D; x + dx[i], b &#x3D; y+dy[i];\n        \n        if(a &gt;&#x3D; 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 5)&#x2F;&#x2F;如果在范围内\n        &#123;\n            &#x2F;&#x2F;把g[a][b]上的数改变，0--&gt;1 或者 1--&gt;0\n            &#x2F;&#x2F; g[a][b] &#x3D; &#39;0&#39; +(&#39;1&#39; - g[a][b]);\n            g[a][b]^&#x3D;1;&#x2F;&#x2F;异或\n            \n        &#125;\n    &#125;\n&#125;\n\nint work()\n&#123;\n    int ans &#x3D; INF;\n    for(int k &#x3D; 0; k &lt; 1 &lt;&lt; 5; k++) &#x2F;&#x2F;用二进制数的每一位数表示每一个开关的状态\n    &#123;\n        int res &#x3D; 0;\n        char backup[10][10];\n        memcpy(backup,g,sizeof g);\n\n        &#x2F;&#x2F;确定第一行开关的状态，结束之后就不再看第一行了\n        for(int j &#x3D; 0; j &lt; 5; j ++)\n        &#123;\n            if( k&gt;&gt;j&amp;1)&#x2F;&#x2F; 如果k的第j位为1（从低位开始的位数）\n            &#123;\n                res ++;&#x2F;&#x2F;每调整一次开关，当前方案的操作数加一\n                turn(0,j);&#x2F;&#x2F;调整开关\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;递推前n-1行\n        for(int i &#x3D; 0; i&lt;4; i++)\n        &#x2F;&#x2F;i&lt;4 是因为枚举第i行时要把第i+1行的灯都按掉，所以只能枚举到倒数第二行，不能枚举最后一行\n        &#x2F;&#x2F;从第一行开始，如果第一行有‘0’，则把这个‘0’下面的开关按一下。\n            for(int j &#x3D; 0; j &lt; 5; j++)\n                if(g[i][j] &#x3D;&#x3D; &#39;0&#39;)\n                &#123;\n                    res++;&#x2F;&#x2F;操作数加一\n                    turn(i+1,j);&#x2F;&#x2F;操作之后，当前位置从‘0’变为‘1’；\n                &#125;\n        \n        &#x2F;&#x2F;枚举完前四行之后，判断最后一行是否全为‘1’\n        bool is_successful &#x3D; true;\n        for(int j &#x3D; 0; j &lt; 5; j ++)\n            if(g[4][j] &#x3D;&#x3D; &#39;0&#39;)&#x2F;&#x2F;如果最后一行某一位是‘0’，则无法完成。\n            &#123;\n                is_successful &#x3D; false;\n                break;\n            &#125;\n        \n        if(is_successful) ans &#x3D; min(ans , res); \n        &#x2F;&#x2F;g数组恢复原状\n        memcpy(g,backup,sizeof g); &#x2F;&#x2F;把g数组恢复原状，重新枚举下一个状况\n    &#125;\n    if(ans &gt; 6) ans &#x3D;  -1;\n    return ans;\n&#125;\n\nint main()\n&#123;\n    int T; \n    cin&gt;&gt;T;\n    while(T--)\n    &#123;\n        for(int i &#x3D; 0; i &lt; 5; i++) cin&gt;&gt;g[i];\n        cout&lt;&lt;work()&lt;&lt;endl;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"题目：95.费解的开关题目介绍你玩过“拉灯”游戏吗？ 25 盏灯排成一个 5×5 的方形。 每一个灯都有一个开关，游戏者可以改变它的状态。 每一步，游戏者可以改变某一个灯的状态。 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字 1...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","count":2,"path":"api/categories/数据结构与算法.json"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","count":1,"path":"api/tags/蓝桥杯.json"},{"name":"递归与递推","slug":"递归与递推","count":1,"path":"api/tags/递归与递推.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%EF%BC%9A95-%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3\"><span class=\"toc-text\">题目：95.费解的开关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">题目介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">解题思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%EF%BC%89\"><span class=\"toc-text\">题解（代码）</span></a></li></ol></li></ol>","author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"计算机组成原理-浮点数","uid":"9ac10ec9c70f0945e2923867a095c3ac","slug":"计算机组成原理-浮点数","date":"2022-01-17T10:56:41.899Z","updated":"2020-09-25T16:56:10.975Z","comments":true,"path":"api/articles/计算机组成原理-浮点数.json","keywords":null,"cover":null,"text":" 浮点数：小数点位置可变，形如科学计数法中的数据表示浮点数格式定义N=Re*MM:尾数，是一个纯小数，表示数据的全部有效数位，其位数决定着数值的精度R:基数，可以取2、8、10、16，表示当前的数制； 微机中，一般默认为2，隐含表示e:阶码，是一个整数，用于支出小数点在该数中的位...","link":"","photos":[],"count_time":{"symbolsCount":427,"symbolsTime":"1 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":3,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","count":3,"path":"api/tags/计算机组成原理.json"}],"author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"算法-递归详解","uid":"82472039c82658fae3f1ced7e41fd7b3","slug":"算法-递归详解","date":"2022-01-17T10:56:41.888Z","updated":"2020-09-25T16:57:43.747Z","comments":true,"path":"api/articles/算法-递归详解.json","keywords":null,"cover":[],"text":" 递归从入门到精通递归入门编写一个递归函数 这个递归函数的功能是什么，怎样调用这个函数，即设计好递归函数的返回值和参数列表 什么时候应该结束这个递归，它的边界条件（出口）是什么 （边界条件） 在非边界情况时，怎样从第n层转变成第n+1层 (递推公式) 计算阶乘(factorial...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"算法","slug":"算法","count":1,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}