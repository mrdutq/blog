{"title":"数据结构-线性表","uid":"cc5068c18e9979834bedd7237675997e","slug":"数据结构-线性表","date":"2022-01-17T10:56:41.812Z","updated":"2020-09-25T16:57:26.074Z","comments":true,"path":"api/articles/数据结构-线性表.json","keywords":null,"cover":null,"content":"<h1 id=\"考核方式\"><a href=\"#考核方式\" class=\"headerlink\" title=\"考核方式\"></a>考核方式</h1><span id=\"more\"></span>\n<p>平时成绩：40%</p>\n<pre><code>作业、考勤：10%\n实验(源代码、实验报告)：15%\n过程性评价(3次，5分/次)：15%\n课堂纪律\n    无故迟到3次=1次旷课\n    无故旷课：-2分/次\n    上课玩手机、玩游戏：-2分/次\n</code></pre>\n<p>期末成绩：60%</p>\n<pre><code>闭卷、笔试\n</code></pre>\n<h1 id=\"抽象数据类型的表示\"><a href=\"#抽象数据类型的表示\" class=\"headerlink\" title=\"抽象数据类型的表示\"></a>抽象数据类型的表示</h1><p>ADT = (D,R,P)</p>\n<p>[D]：数据对象</p>\n<p>[R]：D上的关系集</p>\n<p>[P]：D上的操作集</p>\n<pre><code>ADT抽象数据类型名&#123;\n\n    数据对象:&lt;数据对象的定义&gt;\n\n    数据关系:&lt;数据关系的定义&gt;\n\n    基本操作:&lt;基本操作的定义&gt;\n&#125;ADT抽象数据类型名\n</code></pre>\n<h1 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h1><h2 id=\"推导秘籍\"><a href=\"#推导秘籍\" class=\"headerlink\" title=\"推导秘籍\"></a>推导秘籍</h2><p>1、寻找执行频率最高的那条语句<br>  (通常是循环最内层)</p>\n<p>2、估计出该语句的执行次数<br>(是问题规模n的函数)</p>\n<p>3、只保留最高次幂<br>(去掉最高次幂的系数和其余项)</p>\n<h2 id=\"推导的一般准则\"><a href=\"#推导的一般准则\" class=\"headerlink\" title=\"推导的一般准则\"></a>推导的一般准则</h2><p>准则1、对于一些简单的输入输出语句或赋值语句，近似认为需要O(1)时间。</p>\n<p>准则2、对于多个循环，假设循环体的时间复杂度为O(n),各个循环的循环次数分别是a,b,c…,则这个循环的时间复杂度为O(n<em>a</em>b<em>c</em>…)。</p>\n<p>准则3、如果算法中包含并列的循环，则：若并列循环设计问题规模相同，则取最大；若并列循环设计问题规模不同，则求和。</p>\n<p>准则4、对于条件判断语句，总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度。</p>\n<h1 id=\"线性表的顺序表示和实现\"><a href=\"#线性表的顺序表示和实现\" class=\"headerlink\" title=\"线性表的顺序表示和实现\"></a>线性表的顺序表示和实现</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><pre><code>若结构是非空有限集，则有且仅有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。\n</code></pre>\n<h3 id=\"线性结构可表示为\"><a href=\"#线性结构可表示为\" class=\"headerlink\" title=\"线性结构可表示为\"></a>线性结构可表示为</h3><p>  (a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,a<sub>4</sub>,a<sub>5</sub>,a<sub>6</sub>…)</p>\n<h3 id=\"线性结构反应结点间的逻辑关系是1：1\"><a href=\"#线性结构反应结点间的逻辑关系是1：1\" class=\"headerlink\" title=\"线性结构反应结点间的逻辑关系是1：1\"></a>线性结构反应结点间的逻辑关系是1：1</h3><h3 id=\"线性结构包括：\"><a href=\"#线性结构包括：\" class=\"headerlink\" title=\"线性结构包括：\"></a>线性结构包括：</h3><pre><code>线性表、栈、队列、字符串和数组。\n</code></pre>\n<h3 id=\"线性结构的特点\"><a href=\"#线性结构的特点\" class=\"headerlink\" title=\"线性结构的特点\"></a>线性结构的特点</h3><pre><code>存在唯一的一个被称作“第一个”的数据元素；\n \n存在唯一的一个被称作“最后一个”的数据元素；\n\n除第一个外，集合中的每个数据元素均只有一个直接前驱；\n\n除最后一个之外，集合中每个数据元素均只有一个直接后继。\n</code></pre>\n<p>数据元素都是记录； 元素间关系是线性</p>\n<p><em><strong>同一线性表中的元素必定具有相同特性</strong></em></p>\n<h3 id=\"线性表的类型定义\"><a href=\"#线性表的类型定义\" class=\"headerlink\" title=\"线性表的类型定义\"></a>线性表的类型定义</h3><pre><code>  n个具有相同特性的数据元素的有限序列\n\n  ADT List&#123;\n  数据对象: D=&#123;ai|ai∈ElemSet,i=1,2,...,n,n≥0&#125; \n  数据关系: R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,...,n&#125; \n  基本操作：\n  \n  InitList(&amp;L)\n    操作结果：构造一个空的线性L。\n  \n  DestroyList(&amp;L)    \n    初始条件：线性表L已存在。\n    操作结果：销毁线性表L。\n  \n  ListEmpty(L)    \n    初始条件：线性表L已存在。\n    操作结果：若L为空表，则返回T,否则返回F。\n  \n  ListLength(L)\n    初始条件：线性表L已存在。\n    操作结果：返回L中数据元素个数。\n  \n  GetElem(L,i,&amp;e)\n    初始条件：线性表L已存在，     1≤i≤ListLength(L)。\n    操作结果：用e返回L中第i个数据元素的值。 \n  \n  LocateElem(L,e,compare())\n    初始条件：线性表L已存在，compare()是数据元素判定函数。\n    操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0。\n  \n  PriorElem(L,cur_e,&amp;pre_e)\n    初始条件：线性表L已存在。\n    操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败，pre_e无定义。 \n  \n  NextElem(L,cur_e,&amp;next_e)\n    初始条件：线性表L已存在。\n    操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。\n  \n  ListTraverse(L)\n    初始条件：线性表L已存在。\n    操作结果：对线性表L进行遍历，在遍历过程中依次对L的每个数据元素访问一次。\n  \n  ClearList(&amp;L)\n  初始条件：线性表L已存在。\n  操作结果：将L重置为空表。\n  \n  ListInsert(&amp;L,i,e)\n    初始条件：线性表L已存在，1≤i≤ListLength(L)+1。\n    操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。\n  \n  ListDelete(&amp;L,i,&amp;e)\n    初始条件：线性表L已存在且非空，1≤i≤ListLength(L)。\n    操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1。\n  \n  PutElem(&amp;L, i, e )\n       初始条件：线性表 L 已存在且1≤i≤LengthList(L)。。\n       操作结果：L 中第i 个元素的值与e 相同。\n</code></pre>\n<h3 id=\"线性表的操作主要包括\"><a href=\"#线性表的操作主要包括\" class=\"headerlink\" title=\"线性表的操作主要包括\"></a>线性表的操作主要包括</h3><pre><code>  创建和删除结构\n  对结构有没有改变的操作\n  对结构有改变的操作\n</code></pre>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><h1 id=\"线性表的链式表示和实现\"><a href=\"#线性表的链式表示和实现\" class=\"headerlink\" title=\"线性表的链式表示和实现\"></a>线性表的链式表示和实现</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><h3 id=\"线性表的顺序表示\"><a href=\"#线性表的顺序表示\" class=\"headerlink\" title=\"线性表的顺序表示\"></a>线性表的顺序表示</h3><pre><code>指的是用一组地址连续的存储单元依次存储线性表中的数据元素。\n\n特点：\n  逻辑上相邻的数据元素，物理上也相邻；\n  若已知表中首元素在存储器中的位置，则可求出线性表中其他元素的存放位置\n\n线性表的起始地址（线性表的基地址）\n</code></pre>\n<h2 id=\"顺序表的实现\"><a href=\"#顺序表的实现\" class=\"headerlink\" title=\"顺序表的实现\"></a>顺序表的实现</h2><h3 id=\"顺序表的基本操作\"><a href=\"#顺序表的基本操作\" class=\"headerlink\" title=\"顺序表的基本操作\"></a>顺序表的基本操作</h3><ol>\n<li>初始化顺序表L</li>\n<li> 销毁顺序表L</li>\n<li> 清空顺序表L</li>\n<li> 求顺序表L的长度</li>\n<li> 判断顺序表L是否为空 </li>\n<li> 获取顺序表L中的某个数据元素内容 </li>\n<li> 检索值为e的数据元素    </li>\n<li> 在顺序表L中插入一个数据元素  </li>\n<li> 删除顺序表L中第i个数据元素</li>\n</ol>\n<h3 id=\"线性表顺序表示的优缺点\"><a href=\"#线性表顺序表示的优缺点\" class=\"headerlink\" title=\"线性表顺序表示的优缺点\"></a>线性表顺序表示的优缺点</h3><pre><code>  优点：\n    可以随机存取表中任一元素;\n    无需为表示表中元素之间的逻辑关系而增加额外存储空间；\n  缺点：\n    在插入、删除某一元素时，需要移动大量元素；\n    表的容量难以确定,浪费存储空间\n</code></pre>\n<p>为了克服这一缺点–&gt;链表</p>\n<h2 id=\"线性表的链式存储的特点：\"><a href=\"#线性表的链式存储的特点：\" class=\"headerlink\" title=\"线性表的链式存储的特点：\"></a>线性表的链式存储的特点：</h2><pre><code>  用一组任意的存储单元存储线性表的数据元素\n    存储单元的地址可以连续或不连续\n    即：逻辑上相邻的数据元素在物理上不一定相邻\n  \n  对线性表中的每一个数据元素，都需要用两部分来存储：一部分用于存放数据元素本身的信息，称为数据域（Data Field）；另一部分用于存放直接前驱或直接后继的地址（指针），称为指针域（Link Field）\n</code></pre>\n<h2 id=\"与链式存储有关的术语\"><a href=\"#与链式存储有关的术语\" class=\"headerlink\" title=\"与链式存储有关的术语\"></a>与链式存储有关的术语</h2><p>  结点（Node）：</p>\n<pre><code>数据元素的存储映像  \n  由数据域和指针域两部分组成：数据域Data 指针域Link\n</code></pre>\n<p>  链表：n个结点通过指针域链结称一个链表</p>\n<h2 id=\"链表的种类\"><a href=\"#链表的种类\" class=\"headerlink\" title=\"链表的种类\"></a>链表的种类</h2><p>  单链表<br>      结点只有一个指针域的链表，也称线性链表</p>\n<p>  双链表<br>      有两个指针域的链表</p>\n<p>  循环链表<br>      首尾相接的链表</p>\n<h3 id=\"头指针、首元结点和头结点\"><a href=\"#头指针、首元结点和头结点\" class=\"headerlink\" title=\"头指针、首元结点和头结点\"></a>头指针、首元结点和头结点</h3><pre><code>头指针：指向链表中第一个结点（为头结点或首元结点）的指针\n首元结点：是指链表中存储第一个数据元素a1的结点\n头结点：实在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息\n\n在链表中设置头结点的好处\n</code></pre>\n<h2 id=\"单链表的定义和实现\"><a href=\"#单链表的定义和实现\" class=\"headerlink\" title=\"单链表的定义和实现\"></a>单链表的定义和实现</h2><h2 id=\"单链表的存储结构定义\"><a href=\"#单链表的存储结构定义\" class=\"headerlink\" title=\"单链表的存储结构定义\"></a>单链表的存储结构定义</h2><pre><code>typedef struct LNode&#123;\n  ElemType data;//数据域\n  struct LNode *next;//指针域\n&#125;LNode,*LinkList;\n或者\nstruct LNode&#123;\n  ElemType data;\n  struct LNode *next;\n&#125;;\ntypedef LNode *LinkList;\n或者\ntypedef struct LNode&#123;\n  ElemType data;\n  struct LNode *next;\n&#125;LNode;\ntypedef LNode *LinkList;\n</code></pre>\n<p> 指针变量和结点变量<br>    LNode *p;<br>    LNode n; </p>\n<pre><code>p:指针变量，表示结点地址。\np-&gt;data,p-&gt;next\nn:结点变量，表示一个结点\nn.data;n.next\n</code></pre>\n<p>如何获得后继元素<br>    若p-&gt;data代表ai</p>\n<h2 id=\"单链表基本操作的实现\"><a href=\"#单链表基本操作的实现\" class=\"headerlink\" title=\"单链表基本操作的实现\"></a>单链表基本操作的实现</h2><p>  初始化单链表L</p>\n<p>  销毁单链表L</p>\n<pre><code>Status DestroyList_L(LinkList&amp;L)&#123;\n    LinkList p;\n    while(L)&#123;\n      p=L;\n      L=L-&gt;next;\n      delete p;\n    &#125;\n  return OK;\n&#125;\n</code></pre>\n<p>  清空单链表L</p>\n<pre><code>Status ClearList(LinkList L)&#123;\n  //将L重置为空表\n  LinkList p,q;\n  p=L-&gt;next;//p指向第一个结点\n  while(p)&#123;//没到表尾\n    q=p-&gt;next;\n    delete p;\n    p=q;\n  &#125;\n  L-&gt;next=null;//头结点指针域为空\n  return OK;\n&#125;\n</code></pre>\n<p>  求单链表L的长度</p>\n<pre><code>int ListLength_L(LinkList L)&#123;\n  //返回L中数据元素个数\n  LinkList P；\n  p=L-&gt;next;\n  count = 0;\n  while(p)&#123;\n    ++count;\n    p=p-&gt;next;\n  return count;\n  &#125;\n&#125;\n</code></pre>\n<p>  判断单链表L是否为空</p>\n<pre><code>bool ListEmpty()&#123;\n\n&#125;\n</code></pre>\n<p>  获取单链表L中的某个数据元素内容</p>\n<pre><code>  Status GetElem_L(LinkList L,int i, ElemType &amp;e)&#123;\n    //当第i个元素存在时，其值赋给e并返回OK。否则返回ERROR\n    p=L-&gt;next;\n    j=1;\n\n    while(p&amp;&amp;j&lt;i)&#123;\n      //向后扫描，直到p指向第i个元素或p为空\n      p=p-&gt;next;\n      ++j;\n    &#125;\n    if(!p||j&gt;i)return ERROR;//不合法范围\n    e=p-&gt;data;\n    return OK;\n  &#125;\n</code></pre>\n<p>  检索值为e的数据元素</p>\n<pre><code>  LNode *LocateElem_L(LinkList L , Elemtype e)&#123;\n\n  &#125;\n</code></pre>\n<p>  在单链表L中插入一个数据元素</p>\n<pre><code>Status ListInsert_L(LinkList L,int i , ElemType e)&#123;\n  p=1;j=0;\n  while(p&amp;&amp;j&lt;i-1)&#123;//寻找第i-1个结点\n    p=p-&gt;next;\n    ++i;\n  &#125;\n  if(!p||i&gt;i-1)return ERROR;//i大于表长+1或者小于1\n  s=new LNode;//生成新节点*s\n  s-&gt;data=e;//将节点*s的数据域置为e\n  s-&gt;next=p-&gt;next;//将结点*s插入L中\n  p-&gt;next=s;\n  return OK;\n&#125;\n</code></pre>\n<p>单链表的建立(前插法)</p>\n<pre><code>从一个空表开始，重复读入数据\n    生成新结点\n    将读入数据存放到新节点的数据域中\n    将该新结点插入到...\n</code></pre>\n<p>后插法<br>  从一个空表L开始，将新节点逐个插入到链表的尾部，尾指针r…</p>\n<h2 id=\"链表的运算时间效率分析\"><a href=\"#链表的运算时间效率分析\" class=\"headerlink\" title=\"链表的运算时间效率分析\"></a>链表的运算时间效率分析</h2><h3 id=\"查找-1\"><a href=\"#查找-1\" class=\"headerlink\" title=\"查找\"></a>查找</h3><pre><code>因线性表职能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)\n</code></pre>\n<h3 id=\"插入和删除\"><a href=\"#插入和删除\" class=\"headerlink\" title=\"插入和删除\"></a>插入和删除</h3><pre><code>因线性\n</code></pre>\n<h2 id=\"链表的优缺点\"><a href=\"#链表的优缺点\" class=\"headerlink\" title=\"链表的优缺点\"></a>链表的优缺点</h2><pre><code>优点\n数据元素的个数可以自由扩充\n插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高\n  \n缺点\n存储密度笑\n存取效率不高，必须采用顺序存取\n</code></pre>\n<h2 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h2><pre><code>将单链表中最后一个结点的指针域指向头结点，整个链表形成一个环。\n(a)非空单循环链表\n  特点：从表中任一结点出发均可找到表中其他结点\n(b)空表\n\n与单链表的区别：查找结束条件\n单链表---p-&gt;next=null\n循环链表--p-&gt;next=head\n\n设立尾指针：可以使链表合并简化\n</code></pre>\n<h2 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h2><pre><code>既有前驱指针，也有后继指针\n</code></pre>\n<h2 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h2>","text":"考核方式 平时成绩：40% 作业、考勤：10% 实验(源代码、实验报告)：15% 过程性评价(3次，5分/次)：15% 课堂纪律 无故迟到3次=1次旷课 无故旷课：-2分/次 上课玩手机、玩游戏：-2分/次 期末成绩：60% 闭卷、笔试 抽象数据类型的表示ADT = (D,R,P...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%80%83%E6%A0%B8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">考核方式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">抽象数据类型的表示</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">时间复杂度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A8%E5%AF%BC%E7%A7%98%E7%B1%8D\"><span class=\"toc-text\">推导秘籍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%A8%E5%AF%BC%E7%9A%84%E4%B8%80%E8%88%AC%E5%87%86%E5%88%99\"><span class=\"toc-text\">推导的一般准则</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">线性表的顺序表示和实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A1%A8%E7%A4%BA%E4%B8%BA\"><span class=\"toc-text\">线性结构可表示为</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%8F%8D%E5%BA%94%E7%BB%93%E7%82%B9%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB%E6%98%AF1%EF%BC%9A1\"><span class=\"toc-text\">线性结构反应结点间的逻辑关系是1：1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%8C%85%E6%8B%AC%EF%BC%9A\"><span class=\"toc-text\">线性结构包括：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">线性结构的特点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">线性表的类型定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC\"><span class=\"toc-text\">线性表的操作主要包括</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">插入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">删除</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">线性表的链式表示和实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89-1\"><span class=\"toc-text\">定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">线性表的顺序表示</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">顺序表的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">顺序表的基本操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">线性表顺序表示的优缺点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">线性表的链式存储的特点：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%9C%89%E5%85%B3%E7%9A%84%E6%9C%AF%E8%AF%AD\"><span class=\"toc-text\">与链式存储有关的术语</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">链表的种类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%B4%E6%8C%87%E9%92%88%E3%80%81%E9%A6%96%E5%85%83%E7%BB%93%E7%82%B9%E5%92%8C%E5%A4%B4%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">头指针、首元结点和头结点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">单链表的定义和实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">单链表的存储结构定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">单链表基本操作的实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%90%E7%AE%97%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90\"><span class=\"toc-text\">链表的运算时间效率分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E6%89%BE-1\"><span class=\"toc-text\">查找</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">插入和删除</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">链表的优缺点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">循环链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双向链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">顺序表和链表的比较</span></a></li></ol></li></ol>","author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数据结构-绪论","uid":"12663d3ec3c5f0fc6b418f272e79efac","slug":"数据结构-绪论","date":"2022-01-17T10:56:41.817Z","updated":"2020-09-25T16:57:18.082Z","comments":true,"path":"api/articles/数据结构-绪论.json","keywords":null,"cover":null,"text":"基本概念 数据(data): 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。 数据项(Data Item): 是组成数据元素的、有独立含义的、不可分割的最小单位。 数据元素(Data Element): 是数据的基本单位，在计算机中通常作为一个整体进...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"}],"author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"操作系统-进程的描述与控制","uid":"232069321853689fdbb7d700cb818436","slug":"操作系统-进程的描述与控制","date":"2022-01-17T10:56:41.805Z","updated":"2020-10-20T09:17:36.209Z","comments":true,"path":"api/articles/操作系统-进程的描述与控制.json","keywords":null,"cover":[],"text":"第二章进程的描述与控制前驱图和程序执行前驱图 前趋图：有向无循环图（DAG ）。描述一个程序的各部分（程序段或语句）间的依赖关系，或者是一个大的计算的各个子任务间的因果（前后）关系。 前驱图的定义 前趋图中的每个结点可以表示一条语句、一个程序段或一个进程，结点间的有向边表示两个结...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"操作系统","slug":"操作系统","count":7,"path":"api/categories/操作系统.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":7,"path":"api/tags/操作系统.json"},{"name":"进程","slug":"进程","count":1,"path":"api/tags/进程.json"}],"author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}