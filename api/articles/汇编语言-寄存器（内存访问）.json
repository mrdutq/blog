{"title":"汇编语言_寄存器（内存访问）","uid":"c343f83bed72a2ec56171e72980851e4","slug":"汇编语言-寄存器（内存访问）","date":"2022-01-17T10:56:41.871Z","updated":"2020-10-22T11:25:32.189Z","comments":true,"path":"api/articles/汇编语言-寄存器（内存访问）.json","keywords":null,"cover":null,"content":"<h1 id=\"第3章-寄存器（内存访问）\"><a href=\"#第3章-寄存器（内存访问）\" class=\"headerlink\" title=\"第3章 寄存器（内存访问）\"></a>第3章 寄存器（内存访问）</h1><h2 id=\"3-1-内存中字的存储\"><a href=\"#3-1-内存中字的存储\" class=\"headerlink\" title=\"3.1 内存中字的存储\"></a>3.1 内存中字的存储</h2><ul>\n<li>任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们堪称两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和地位字节单元。</li>\n<li>高高低低原则：高位存放在高地址，低位存放在低地址。</li>\n</ul>\n<h2 id=\"3-2-DS和-address\"><a href=\"#3-2-DS和-address\" class=\"headerlink\" title=\"3.2 DS和[address]\"></a>3.2 DS和[address]</h2><ul>\n<li>CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；</li>\n<li>在8086PC中，内存地址由段地址和偏移地址组成。</li>\n<li>8086CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。</li>\n<li>8086CPU不支持将数据直接送入段寄存器的操作，DS是一个段寄存器。</li>\n<li>数据–&gt;通用寄存器–&gt;段寄存器</li>\n<li>怎样将数据从寄存器送入内存单元?<ul>\n<li>mov bx,1000H</li>\n<li>mov ds,bx</li>\n<li>mov [0],al</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-3-字的传送\"><a href=\"#3-3-字的传送\" class=\"headerlink\" title=\"3.3 字的传送\"></a>3.3 字的传送</h2><ul>\n<li>因为8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，也就是一次性传送一个字。</li>\n<li>比如：<ul>\n<li>mov bx,1000H</li>\n<li>mov ds,bx</li>\n<li>mov ax,[0] ;1000:0处的字型数据送入AX</li>\n<li>mov [0],cx ;CX中的16位数据送到1000:0处</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-4-mov、add、sub指令\"><a href=\"#3-4-mov、add、sub指令\" class=\"headerlink\" title=\"3.4 mov、add、sub指令\"></a>3.4 mov、add、sub指令</h2><ul>\n<li>已学过mov指令的几种形式<ul>\n<li>mov 寄存器，数据<ul>\n<li>mov ax,6</li>\n</ul>\n</li>\n<li>mov 寄存器，寄存器<ul>\n<li>mov bx,ax</li>\n</ul>\n</li>\n<li>mov 寄存器，内存单元<ul>\n<li>mov ax,[0]</li>\n</ul>\n</li>\n<li>mov 内存单元，寄存器<ul>\n<li>mov [0],ax</li>\n</ul>\n</li>\n<li>mov 段寄存器，寄存器<ul>\n<li>mov ds,ax</li>\n</ul>\n</li>\n<li>mov 寄存器，段寄存器<ul>\n<li>mov ax,ds</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>add指令  <ul>\n<li>add 寄存器，数据<ul>\n<li>add ax,6</li>\n</ul>\n</li>\n<li>add 寄存器，寄存器<ul>\n<li>add bx,ax</li>\n</ul>\n</li>\n<li>add 寄存器，内存单元<ul>\n<li>add ax,[0]</li>\n</ul>\n</li>\n<li>add 内存单元，寄存器<ul>\n<li>add [0],ax</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>sub指令<ul>\n<li>sub 寄存器，数据<ul>\n<li>sub ax,6</li>\n</ul>\n</li>\n<li>sub 寄存器，寄存器<ul>\n<li>sub bx,ax</li>\n</ul>\n</li>\n<li>sub 寄存器，内存单元<ul>\n<li>sub ax,[0]</li>\n</ul>\n</li>\n<li>sub 内存单元，寄存器<ul>\n<li>sub [0],ax</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-5-数据段\"><a href=\"#3-5-数据段\" class=\"headerlink\" title=\"3.5 数据段\"></a>3.5 数据段</h2><ul>\n<li>对于8086PC机，可以根据需要将一组内存单元定义为一个段（可以是代码段、数据段等）</li>\n<li>可以将一组长度为N（N&lt;=64K）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。</li>\n</ul>\n<h2 id=\"3-1-3-5-小结\"><a href=\"#3-1-3-5-小结\" class=\"headerlink\" title=\"3.1~3.5 小结\"></a>3.1~3.5 小结</h2><ul>\n<li>(1) 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节放在低地址单元中，高位字节存放在高地址单元中。</li>\n<li>(2) 用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。</li>\n<li>(3) [address]表示一个偏移地址为address的内存单元。</li>\n<li>(4) 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。</li>\n<li>(5) mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令</li>\n<li>(6) 可以根据自己的推测，在debug中实验指令的新格式。</li>\n</ul>\n<h2 id=\"3-6-栈\"><a href=\"#3-6-栈\" class=\"headerlink\" title=\"3.6 栈\"></a>3.6 栈</h2><ul>\n<li>栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于“后进先出”。</li>\n<li>栈有两个基本操作：入栈和出栈<ul>\n<li>入栈：将一个新的元素放到栈顶。</li>\n<li>出栈：从栈顶取出一个元素。</li>\n</ul>\n</li>\n<li>栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。</li>\n<li>栈的操作规则：LIFO（Last In First Out，后进先出）</li>\n</ul>\n<h2 id=\"3-7-CPU提供的栈机制\"><a href=\"#3-7-CPU提供的栈机制\" class=\"headerlink\" title=\"3.7 CPU提供的栈机制\"></a>3.7 CPU提供的栈机制</h2><ul>\n<li>8086CPU中提供相关的指令来以栈的方式访问内存空间。这意味着，我们在基于8086CPU编程的时候可以将一段内存当作栈来使用。</li>\n<li>8086CPU提供入栈和出栈指令：（最基本的）<ul>\n<li>PUSH（入栈）</li>\n<li>POP（出栈）</li>\n<li>push ax: 将寄存器ax中的数据送入栈中；</li>\n<li>pop ax：从栈顶取出数据送入ax。</li>\n</ul>\n</li>\n<li>8086CPU的入栈和出栈操作都是以字为单位进行的。<ul>\n<li>字型数据用两个单元存放，高地址单元放高8位，低地址单元放低8位。</li>\n</ul>\n</li>\n<li>CPU如何知道一段内存空间被当作栈使用？<ul>\n<li>寄存器CS和IP中存放着当前指令的段地址和偏移地址。</li>\n<li>8086CPU中有两个寄存器：<ul>\n<li>段寄存器SS：存放栈顶的段地址</li>\n<li>寄存器SP：存放栈顶的偏移地址</li>\n</ul>\n</li>\n<li>任意时刻，SS：SP指向栈顶元素</li>\n</ul>\n</li>\n<li>执行push和pop的时候，如何知道哪个单元是栈顶单元？<ul>\n<li>push ax<ul>\n<li>（1）SP=SP-2;</li>\n<li>（2）将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶。</li>\n</ul>\n</li>\n<li>pop ax<ul>\n<li>（1）将SS：SP指向的内存单元处的数据送入ax中;</li>\n<li>（2）SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果我们将10000H~1000FH这段空间当作栈，初始状态栈是空的，此时，SS=1000H，SP=？<ul>\n<li>栈空，SS：SP指向栈空间最高地址单元的下一个单元（10010H），此时，SS=1000H，SP=10H</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-8-栈顶超界问题\"><a href=\"#3-8-栈顶超界问题\" class=\"headerlink\" title=\"3.8 栈顶超界问题\"></a>3.8 栈顶超界问题</h2><ul>\n<li>SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈时找到栈顶。</li>\n<li>如何能够保证在入栈、出栈时，栈顶不会超出栈空间？<ul>\n<li>当栈满的时候再使用push指令入栈，栈空的时候再使用pop指令出栈都将发生栈顶越界问题。</li>\n<li>栈顶越界是危险的。<ul>\n<li>因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己的程序中的，也可能是别的程序中的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>8086CPU不保证对栈的操作不会越界。这就是说8086CPU只知道栈顶在何处（由SS：SP指示），而不知道读者安排的栈空间有多大。这点就好像，CPU只知道当前要执行的指令在何处（由CS：SP指示）而不知道读者要执行的指令有多少。<ul>\n<li>8086CPU的工作机理，只考虑当前的情况：<ul>\n<li>当前栈顶在何处；</li>\n<li>当前要执行的指令是哪一条。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>结论：<ul>\n<li>我们在编程的时候要自己操心栈顶越界的问题，要根据可能用到的最大栈空间来安排栈的大小，防止入栈的数据太多而导致的越界；</li>\n<li>执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的越界。</li>\n</ul>\n</li>\n<li>栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式（后进先出）进行访问的内存空间。</li>\n</ul>\n<h2 id=\"3-9-push、pop指令\"><a href=\"#3-9-push、pop指令\" class=\"headerlink\" title=\"3.9 push、pop指令\"></a>3.9 push、pop指令</h2><ul>\n<li>push和pop指令是可以在寄存器和内存之间传送数据的。</li>\n<li>push 寄存器；pop寄存器<ul>\n<li>push ax<ul>\n<li>（1）SP=SP-2;</li>\n<li>（2）将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶。</li>\n</ul>\n</li>\n<li>pop ax<ul>\n<li>（1）将SS：SP指向的内存单元处的数据送入ax中;</li>\n<li>（2）SP=SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>push、pop可以对段寄存器进行操作<ul>\n<li>push ds</li>\n<li>push es</li>\n</ul>\n</li>\n<li>push、pop 内存单元<ul>\n<li>push 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位的）<ul>\n<li>push [0]</li>\n</ul>\n</li>\n<li>pop 内存单元： 出栈，用一个内存字单元接收出栈的数据<ul>\n<li>pop [2]</li>\n</ul>\n</li>\n<li>指令执行时,CPU要知道内存单元的地址，可以push、pop指令中给出内存单元的偏移地址，段地址可以在指令执行时，CPU从ds中取得。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ul>\n<li>push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。</li>\n<li>提供：SS、SP指示栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。</li>\n<li>这就是8086CPU提供的栈操作机制。</li>\n</ul>\n<h2 id=\"3-10-栈段\"><a href=\"#3-10-栈段\" class=\"headerlink\" title=\"3.10 栈段\"></a>3.10 栈段</h2><ul>\n<li>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。</li>\n<li>可以将长度为N（N&lt;=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈来使用，从而定义了一个栈段。</li>\n<li>比如：将10010H~1001FH这段长度为16字节的内存当作栈来使用，以栈的方式进行访问。这段空间就可以成为栈段，段地址为1000H，大小为16字节。</li>\n<li>将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排就执行push、pop等栈操作指令时就自动地将我们定义的栈段当作栈空间来访问。</li>\n<li>如何使用push、pop等栈操作指令访问我们定义的栈段呢？<ul>\n<li>将SS：SP指向我们定义的栈段。</li>\n</ul>\n</li>\n</ul>\n","text":"第3章 寄存器（内存访问）3.1 内存中字的存储 任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们堪称两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和地位字节单元。 高高低低原则：高位存放在高地址，低位存放在低地址。 3.2 DS和[address] ...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"汇编语言","slug":"汇编语言","count":4,"path":"api/categories/汇编语言.json"}],"tags":[{"name":"汇编语言","slug":"汇编语言","count":4,"path":"api/tags/汇编语言.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC3%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89\"><span class=\"toc-text\">第3章 寄存器（内存访问）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%97%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">3.1 内存中字的存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-DS%E5%92%8C-address\"><span class=\"toc-text\">3.2 DS和[address]</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%AD%97%E7%9A%84%E4%BC%A0%E9%80%81\"><span class=\"toc-text\">3.3 字的传送</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-mov%E3%80%81add%E3%80%81sub%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3.4 mov、add、sub指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-%E6%95%B0%E6%8D%AE%E6%AE%B5\"><span class=\"toc-text\">3.5 数据段</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-3-5-%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">3.1~3.5 小结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-%E6%A0%88\"><span class=\"toc-text\">3.6 栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-7-CPU%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">3.7 CPU提供的栈机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-8-%E6%A0%88%E9%A1%B6%E8%B6%85%E7%95%8C%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.8 栈顶超界问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-9-push%E3%80%81pop%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3.9 push、pop指令</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-10-%E6%A0%88%E6%AE%B5\"><span class=\"toc-text\">3.10 栈段</span></a></li></ol></li></ol>","author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"汇编语言_程序","uid":"7bf39dc8b36d692ca5cc6dcb2f7992e5","slug":"汇编语言-程序","date":"2022-01-17T10:56:41.876Z","updated":"2020-10-25T15:07:50.242Z","comments":true,"path":"api/articles/汇编语言-程序.json","keywords":null,"cover":null,"text":"程序一个源程序从写出到执行的过程 编写 编译连接 使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件(.obj) 再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件(.exe)。 执行（可执行文件） 程序（...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"汇编语言","slug":"汇编语言","count":4,"path":"api/categories/汇编语言.json"}],"tags":[{"name":"汇编语言","slug":"汇编语言","count":4,"path":"api/tags/汇编语言.json"}],"author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"汇编语言_寄存器（CPU工作原理）","uid":"f400084cdc57c1ce1c5f51d765d1c6cd","slug":"汇编语言-寄存器（CPU工作原理）","date":"2022-01-17T10:56:41.865Z","updated":"2020-10-21T07:55:54.579Z","comments":true,"path":"api/articles/汇编语言-寄存器（CPU工作原理）.json","keywords":null,"cover":null,"text":"第2章 寄存器（CPU工作原理） CPU概述 一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。 区别： 内部总线实现CPU内部各个器件之间的联系。 外部总线实现CPU和主板上其他器件的联系。 寄存器概述 8086CPU有14个寄存器 AX、BX、CX、...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"汇编语言","slug":"汇编语言","count":4,"path":"api/categories/汇编语言.json"}],"tags":[{"name":"汇编语言","slug":"汇编语言","count":4,"path":"api/tags/汇编语言.json"}],"author":{"name":"天琦","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"为天地立心，为生民立命，为往圣继绝学，为万世开太平！！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}